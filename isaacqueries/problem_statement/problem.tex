\problemname{Isaac's Queries}

\begin{center}
\includegraphics[width=5cm]{isaacqueries-isaac.png}
\\
\emph{Image credits:  Photo by Michael Ocampo, CC BY 2.0, modified to remove background, via Wikimedia Commons}
\end{center}

You have reached the final level of the popular roguelike game ``Isaac's Keybindings''. Instead of a boss, you encounter a shopkeeper who holds a hidden array of integers $a_1, a_2, \ldots, a_n$, where $0 \leq a_i < 2^{30}$ for each $i$ in $[1, n]$.

It is guaranteed that \textbf{the array is generated randomly}, i.e., $a_i$ is a uniformly random integer in $[0, 2^{30})$ for each $i$ in $[1, n]$, in all the tests excluding the example.

Let $f(u, v) = a_u \oplus a_{u+1} \oplus \ldots \oplus a_v$, where $\oplus$ is the bitwise $\texttt{XOR}$.

You can ask queries of the following form: $\texttt{? u v}$, with $1 \leq u \leq v \leq n$.

The answer to the query is:
\begin{itemize}
\item $-1$, if $f(u, v) = 0$;
\item $\lfloor \log_2(f(u, v)) \rfloor$ otherwise.
\end{itemize}

Each query has a cost of $\frac{1}{v-u+1}$ robocoins. You initially have $35$ robocoins and if your balance ever becomes negative you lose. Note that your robocoin balance does not need to be an integer at any moment.

Find the answer to all possible $\frac{n(n+1)}{2}$ queries without losing.



\section*{Input}
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 30$). The description of the test cases follows.

The first line of each test case contains one integer $n$ ($1 \leq n \leq 100$)~--- the length of the array $a_1, a_2, \ldots, a_n$. It is guaranteed that the array is generated randomly in all the tests excluding the example.

There are exactly $50$ tests in this problem (including the example). The example has $t = 1$ and $n = 3$, and all the other tests have $t = 30$ and $n = 100$.




\section*{Interaction}
For each test case, first read a single integer $n$. If the integer you read is $-2$, it means that the answer to the previous test case was wrong, and you should exit immediately.

To ask a query, print a line in the format $\texttt{? u v}$ with $1 \leq u \leq v \leq n$.

As a response to the query, you will receive $-2$ if you made an invalid query (i.e., the format is invalid, or you would reach a negative amount of robocoins). In that case, you should exit immediately. Otherwise, you will receive the answer to the query.

When you determine the answers to all the $\frac{n(n+1)}{2}$ queries, print them in the following format.

Print $n+1$ lines. The first line must contain a single character $\texttt{!}$. The $i$-th of the next $n$ lines must contain $n-i+1$ integers: the answers to queries $\texttt{? i i}, \, \texttt{? i i+1}, \,\ldots, \, \texttt{? i n}$, respectively.

After printing a query, do not forget to output the end of line and flush the output. To do this, use:

\begin{itemize}
\item $\texttt{fflush(stdout)}$ or $\texttt{cout.flush()}$ in C++;
\item $\texttt{System.out.flush()}$ in Java;
\item $\texttt{stdout.flush()}$ in Python;
\item see the documentation for other languages.
\end{itemize}

\section*{Samples}
In the example, the hidden array is $[a_1, a_2, a_3] = [2, 4, 6]$.

\begin{itemize}
\item First, you ask $\texttt{? 1 2}$. Since $f(1, 2) = a_1 \oplus a_2 = 6$, the answer is $\lfloor \log_2(6) \rfloor = 2$. 
\item Then, you ask $\texttt{? 1 3}$. Since $f(1, 3) = a_1 \oplus a_2 \oplus a_3 = 0$, the answer is $-1$.
\item Then, you ask $\texttt{? 2 3}$. Since $f(2, 3) = a_2 \oplus a_3 = 2$, the answer is $\lfloor \log_2(2) \rfloor = 1$.
\end{itemize}

Now, even without knowing the hidden array, you claim the answer to all the possible $6$ queries. For example, you claim that the answer to $\texttt{? 1 1}$ is $1$.

You have spent $\frac{1}{2} + \frac{1}{3} + \frac{1}{2} = \frac{4}{3}$ robocoins, which is less than the allowed $35$ robocoins.
